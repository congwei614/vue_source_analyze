/**
 * 补丁标志是编译器生成的优化提示。
 * 当在 diff 过程中遇到带有 dynamicChildren 的块时，算法进入“优化模式”。
 * 在这种模式下，我们知道 vdom 是由一个编译器生成的渲染函数，所以算法只需要处理由这些补丁标志明确标记的更新。
 *
 * 可以使用 | 组合补丁标志，检查可以使用 & 运算符，例如
 *
 * ```js
 * const flag = TEXT | CLASS
 * if (flag & TEXT) { ... }
 * ```
 *
 * 检查 '../../runtime-core/src/renderer.ts' 中的 `patchElement` 函数以查看在 diff 期间如何处理标志。
 *
 * Patch flags are optimization hints generated by the compiler.
 * when a block with dynamicChildren is encountered during diff, the algorithm
 * enters "optimized mode". In this mode, we know that the vdom is produced by
 * a render function generated by the compiler, so the algorithm only needs to
 * handle updates explicitly marked by these patch flags.
 *
 * Patch flags can be combined using the | bitwise operator and can be checked
 * using the & operator, e.g.
 *
 * ```js
 * const flag = TEXT | CLASS
 * if (flag & TEXT) { ... }
 * ```
 *
 * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the
 * flags are handled during diff.
 */
export const enum PatchFlags {
  /**
   * 指示具有动态 textContent 的元素（子快速路径）
   *
   * Indicates an element with dynamic textContent (children fast path)
   */
  TEXT = 1,

  /**
   * 指示具有动态类绑定的元素。
   *
   * Indicates an element with dynamic class binding.
   */
  CLASS = 1 << 1,

  /**
   * 表示具有动态样式的元素
   * 编译器将静态字符串样式预编译成静态对象 + 检测并提升内联静态对象
   *
   * e.g. `style="color: red"` 和 `:style="{ color: 'red' }"` 两者都被提升
   * as:
   * ```js
   * const style = { color: 'red' }
   * render() { return e('div', { style }) }
   * ```
   *
   * Indicates an element with dynamic style
   * The compiler pre-compiles static string styles into static objects
   * + detects and hoists inline static objects
   * e.g. `style="color: red"` and `:style="{ color: 'red' }"` both get hoisted
   * as:
   * ```js
   * const style = { color: 'red' }
   * render() { return e('div', { style }) }
   * ```
   */
  STYLE = 1 << 2,

  /**
   * 表示具有非类/样式动态道具的元素。
   * 也可以在具有任何动态道具的组件上（包括类/风格）。
   * 当这个标志存在时，vnode 也有一个 dynamicProps包含可能更改的道具键的数组，因此运行时可以更快地区分它们（无需担心移除的道具）
   *
   * Indicates an element that has non-class/style dynamic props.
   * Can also be on a component that has any dynamic props (includes
   * class/style). when this flag is present, the vnode also has a dynamicProps
   * array that contains the keys of the props that may change so the runtime
   * can diff them faster (without having to worry about removed props)
   */
  PROPS = 1 << 3,

  /**
   * 表示带有动态键的道具的元素。
   * 当键改变时，一个完整的diff 总是需要删除旧密钥。 这个标志是相互的CLASS、STYLE 和 PROPS 独有。
   *
   * Indicates an element with props with dynamic keys. When keys change, a full
   * diff is always needed to remove the old key. This flag is mutually
   * exclusive with CLASS, STYLE and PROPS.
   */
  FULL_PROPS = 1 << 4,

  /**
   * 表示带有事件监听器的元素（需要附加在hydration期间）
   *
   * Indicates an element with event listeners (which need to be attached
   * during hydration)
   */
  HYDRATE_EVENTS = 1 << 5,

  /**
   * 指示其子顺序不变的片段。
   *
   * Indicates a fragment whose children order doesn't change.
   */
  STABLE_FRAGMENT = 1 << 6,

  /**
   * 指示带有键控或部分键控子级的片段
   *
   * Indicates a fragment with keyed or partially keyed children
   */
  KEYED_FRAGMENT = 1 << 7,

  /**
   * 指示具有未键控子项的片段。
   *
   * Indicates a fragment with unkeyed children.
   */
  UNKEYED_FRAGMENT = 1 << 8,

  /**
   * 表示只需要非道具修补的元素.
   * e.g. 参考或令（onVnodeXXX 挂钩）。 因为每个修补的 vnode 都会检查 refs和 onVnodeXXX 挂钩，它只是标记 vnode，以便父块将跟踪它。
   *
   * Indicates an element that only needs non-props patching, e.g. ref or
   * directives (onVnodeXXX hooks). since every patched vnode checks for refs
   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block
   * will track it.
   */
  NEED_PATCH = 1 << 9,

  /**
   * 表示具有动态插槽的组件（例如，引用 v-for 迭代值的插槽或动态插槽名称）具有此标志的组件始终强制更新。
   *
   * Indicates a component with dynamic slots (e.g. slot that references a v-for
   * iterated value, or dynamic slot names).
   * Components with this flag are always force updated.
   */
  DYNAMIC_SLOTS = 1 << 10,

  /**
   * 表示仅因为用户在模板的根级别放置评论而创建的片段。
   * 这是一个仅限开发人员的标志，因为注释在生产中被剥离。
   *
   * Indicates a fragment that was created only because the user has placed
   * comments at the root level of a template. This is a dev-only flag since
   * comments are stripped in production.
   */
  DEV_ROOT_FRAGMENT = 1 << 11,

  /**
   * 特殊标志 -------------------------------------------------------------
   * 特殊标志是负整数。
   * 它们永远不会使用按位运算符进行匹配（按位匹配应该只发生在 patchFlag > 0 的分支中），并且是互斥的。
   * 检查特殊标志时，只需检查 patchFlag === FLAG。
   *
   * SPECIAL FLAGS -------------------------------------------------------------
   * Special flags are negative integers. They are never matched against using
   * bitwise operators (bitwise matching should only happen in branches where
   * patchFlag > 0), and are mutually exclusive. When checking for a special
   * flag, simply check patchFlag === FLAG.
   */

  /**
   * 表示一个已提升的静态 vnode。
   * 这是跳过hydration的提示整个子树，因为静态内容永远不需要更新。
   *
   * Indicates a hoisted static vnode. This is a hint for hydration to skip
   * the entire sub tree since static content never needs to be updated.
   */
  HOISTED = -1,
  /**
   * 一个特殊标志，表示差异算法应该退出优化模式。
   * e.g. 在遇到非编译器生成的插槽时由 renderSlot() 创建的块片段（即手动编写的渲染函数，应该始终完全区分）或手动克隆VNodes
   *
   * A special flag that indicates that the diffing algorithm should bail out
   * of optimized mode. For example, on block fragments created by renderSlot()
   * when encountering non-compiler generated slots (i.e. manually written
   * render functions, which should always be fully diffed)
   * OR manually cloneVNodes
   */
  BAIL = -2
}

/**
 * 仅开发标志 -> 名称映射
 *
 * dev only flag -> name mapping
 */
export const PatchFlagNames = {
  [PatchFlags.TEXT]: `TEXT`,
  [PatchFlags.CLASS]: `CLASS`,
  [PatchFlags.STYLE]: `STYLE`,
  [PatchFlags.PROPS]: `PROPS`,
  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,
  [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`,
  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,
  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,
  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,
  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,
  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,
  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,
  [PatchFlags.HOISTED]: `HOISTED`,
  [PatchFlags.BAIL]: `BAIL`
}
